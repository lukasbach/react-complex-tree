"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8386],{1861:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var r=n(7896),a=(n(2784),n(876));const i={sidebar_position:2.5},o="Custom Tree Data Provider",s={unversionedId:"guides/custom-data-provider",id:"guides/custom-data-provider",title:"Custom Tree Data Provider",description:"In more complex scenarios, it's probably easiest to implement your own data provider.",source:"@site/docs/guides/custom-data-provider.mdx",sourceDirName:"guides",slug:"/guides/custom-data-provider",permalink:"/docs/guides/custom-data-provider",draft:!1,editUrl:"https://github.com/lukasbach/react-complex-tree/edit/main/packages/docs/docs/guides/custom-data-provider.mdx",tags:[],version:"current",sidebarPosition:2.5,frontMatter:{sidebar_position:2.5},sidebar:"tutorialSidebar",previous:{title:"Static Tree Data Provider",permalink:"/docs/guides/static-data-provider"},next:{title:"Controlled Environment",permalink:"/docs/guides/controlled-environment"}},d={},m=[{value:"Reacting to Drag Events",id:"reacting-to-drag-events",level:2},{value:"Reacting to Rename Events",id:"reacting-to-rename-events",level:2},{value:"Custom Provider Live Demo",id:"custom-provider-live-demo",level:2}],l={toc:m};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"custom-tree-data-provider"},"Custom Tree Data Provider"),(0,a.kt)("p",null,"In more complex scenarios, it's probably easiest to implement your own data provider.\nThis provider must implement the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/interfaces/TreeDataProvider"},"TreeDataProvider interface"),", i.e."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface TreeDataProvider<T = any> {\n  onDidChangeTreeData?: (listener: (changedItemIds: TreeItemIndex[]) => void) => Disposable;\n  getTreeItem: (itemId: TreeItemIndex) => Promise<TreeItem<T>>;\n  getTreeItems?: (itemIds: TreeItemIndex[]) => Promise<TreeItem[]>;\n  onRenameItem?: (item: TreeItem<T>, name: string) => Promise<void>;\n  onChangeItemChildren?: (itemId: TreeItemIndex, newChildren: TreeItemIndex[]) => Promise<void>;\n}\n")),(0,a.kt)("p",null,"At least the ",(0,a.kt)("inlineCode",{parentName:"p"},"getTreeItem")," method must be implemented, to declare how data can be made available\nto the tree structure. ",(0,a.kt)("inlineCode",{parentName:"p"},"getTreeItems")," allows you to make loading more efficient if multiple entries\nneed to be loaded at once. If you do not implement ",(0,a.kt)("inlineCode",{parentName:"p"},"getTreeItems"),", they are loaded sequentially\nusing ",(0,a.kt)("inlineCode",{parentName:"p"},"getTreeItem"),"."),(0,a.kt)("p",null,"The methods ",(0,a.kt)("inlineCode",{parentName:"p"},"onRenameItem")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"onChangeItemChildren")," allow you to declare how updates to the\ntree structure should be handled, i.e. by renaming an item or moving items from one parent to\nanother. You still need to enable this functionality in the environment by providing the respective\nflags. Look into the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/interfaces/TreeCapabilities"},"TreeCapabilities interface")," for more details\non the necessary flags."),(0,a.kt)("p",null,"You can use this implementation as baseline:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"\nclass CustomDataProviderImplementation implements TreeDataProvider {\n  private data: Record<TreeItemIndex, TreeItem> = { ...shortTree.items };\n\n  private treeChangeListeners: ((changedItemIds: TreeItemIndex[]) => void)[] =\n    [];\n\n  public async getTreeItem(itemId: TreeItemIndex) {\n    return this.data[itemId];\n  }\n\n  public async onChangeItemChildren(\n    itemId: TreeItemIndex,\n    newChildren: TreeItemIndex[]\n  ) {\n    this.data[itemId].children = newChildren;\n    this.treeChangeListeners.forEach(listener => listener([itemId]));\n  }\n\n  public onDidChangeTreeData(\n    listener: (changedItemIds: TreeItemIndex[]) => void\n  ): Disposable {\n    this.treeChangeListeners.push(listener);\n    return {\n      dispose: () =>\n        this.treeChangeListeners.splice(\n          this.treeChangeListeners.indexOf(listener),\n          1\n        ),\n    };\n  }\n\n  public async onRenameItem(item: TreeItem<any>, name: string): Promise<void> {\n    this.data[item.index].data = name;\n  }\n\n  // custom handler for directly manipulating the tree data\n  public injectItem(name: string) {\n    const rand = `${Math.random()}`;\n    this.data[rand] = { data: name, index: rand } as TreeItem;\n    this.data.root.children?.push(rand);\n    this.treeChangeListeners.forEach(listener => listener(['root']));\n  }\n}\n")),(0,a.kt)("h2",{id:"reacting-to-drag-events"},"Reacting to Drag Events"),(0,a.kt)("p",null,"RCT will call ",(0,a.kt)("inlineCode",{parentName:"p"},"onChangeItemChildren")," when a drag operation is finished. You can use this directly\nto update your data source. Note that, if you add or remove items, the affected item\nis the parent item, not the added or removed items."),(0,a.kt)("p",null,"In the exemplary implementation above, this emits an event on the ",(0,a.kt)("inlineCode",{parentName:"p"},"treeChangeListeners")," listeners,\nwhere you could register a custom listener to react to changes."),(0,a.kt)("h2",{id:"reacting-to-rename-events"},"Reacting to Rename Events"),(0,a.kt)("p",null,"RCT will call ",(0,a.kt)("inlineCode",{parentName:"p"},"onRenameItem")," when a rename operation is finished. Implement your rename logic there."),(0,a.kt)("h2",{id:"custom-provider-live-demo"},"Custom Provider Live Demo"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  const dataProvider = useMemo(\n    () => {\n      class CustomDataProviderImplementation {\n        data = { ...shortTree.items };\n\n        treeChangeListeners = [];\n\n        async getTreeItem(itemId) {\n          return this.data[itemId];\n        }\n\n        async onChangeItemChildren(itemId, newChildren) {\n          this.data[itemId].children = newChildren;\n          this.treeChangeListeners.forEach(listener => listener([itemId]));\n        }\n\n        onDidChangeTreeData(listener) {\n          this.treeChangeListeners.push(listener);\n          return {\n            dispose: () =>\n              this.treeChangeListeners.splice(\n                this.treeChangeListeners.indexOf(listener),\n                1\n              ),\n          };\n        }\n\n        async onRenameItem(item, name) {\n          this.data[item.index].data = name;\n        }\n\n        injectItem(name) {\n          const rand = `${Math.random()}`;\n          this.data[rand] = { data: name, index: rand };\n          this.data.root.children.push(rand);\n          this.treeChangeListeners.forEach(listener => listener(['root']));\n        }\n      }\n      return new CustomDataProviderImplementation()\n    },\n    []\n  );\n\n  return (\n    <UncontrolledTreeEnvironment\n      canDragAndDrop\n      canDropOnFolder\n      canReorderItems\n      dataProvider={dataProvider}\n      getItemTitle={item => item.data}\n      viewState={{\n        'tree-2': {\n          expandedItems: [],\n        },\n      }}\n    >\n      <button\n        type=\"button\"\n        onClick={() =>\n          dataProvider.injectItem(window.prompt('Item name') || 'New item')\n        }\n      >\n        Inject item\n      </button>\n      <Tree treeId=\"tree-2\" rootItem=\"root\" treeLabel=\"Tree Example\" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n")))}c.isMDXComponent=!0},876:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>u});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),m=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=m(e.components);return r.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,d=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=m(n),u=a,h=p["".concat(d,".").concat(u)]||p[u]||c[u]||i;return n?r.createElement(h,o(o({ref:t},l),{},{components:n})):r.createElement(h,o({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var m=2;m<i;m++)o[m]=n[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);