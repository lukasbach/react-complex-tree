"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4156],{4703:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var r=n(7896),a=(n(2784),n(876));const o={sidebar_position:2},i="Static Tree Data Provider",d={unversionedId:"guides/static-data-provider",id:"guides/static-data-provider",title:"Static Tree Data Provider",description:"When using an uncontrolled environment, you need to provide your data by supplying a data provider. The",source:"@site/docs/guides/static-data-provider.mdx",sourceDirName:"guides",slug:"/guides/static-data-provider",permalink:"/docs/guides/static-data-provider",draft:!1,editUrl:"https://github.com/lukasbach/react-complex-tree/edit/main/packages/docs/docs/guides/static-data-provider.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Uncontrolled Environment",permalink:"/docs/guides/uncontrolled-environment"},next:{title:"Custom Tree Data Provider",permalink:"/docs/guides/custom-data-provider"}},s={},c=[{value:"Creating the data provider with data",id:"creating-the-data-provider-with-data",level:2},{value:"Apply changes from outside",id:"apply-changes-from-outside",level:2},{value:"Reacting to Drag Events",id:"reacting-to-drag-events",level:2},{value:"Reacting to Rename Events",id:"reacting-to-rename-events",level:2}],l={toc:c};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"static-tree-data-provider"},"Static Tree Data Provider"),(0,a.kt)("p",null,"When using an uncontrolled environment, you need to provide your data by supplying a data provider. The\neasiest way to get started is using the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/classes/StaticTreeDataProvider"},"Static Tree Data Provider"),".\nIt allows you to provide your data as record which maps item ids to tree items, and gives you the possibility\nto react to changes in the tree structure, as well as inject your own changes through change events."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you want to implement a custom data provider your own, you can find a comprehensive guide ",(0,a.kt)("a",{parentName:"p",href:"/docs/guides/custom-data-provider"},"here"),".")),(0,a.kt)("p",null,"The following example gives a good example of what is possible with static tree data providers. We will look\ninto the details of the data provider below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function App() {\n  const items = useMemo(() => ({ ...shortTree.items }), []);\n  const dataProvider = useMemo(\n    () =>\n      new StaticTreeDataProvider(items, (item, data) => ({\n        ...item,\n        data,\n      })),\n    [items]\n  );\n\n  const injectItem = () => {\n    const rand = `${Math.random()}`;\n    items[rand] = { data: \'New Item\', index: rand };\n    items.root.children.push(rand);\n    dataProvider.onDidChangeTreeDataEmitter.emit([\'root\']);\n  };\n\n  const removeItem = () => {\n    if (items.root.children.length === 0) return;\n    items.root.children.pop();\n    dataProvider.onDidChangeTreeDataEmitter.emit([\'root\']);\n  };\n\n  return (\n    <UncontrolledTreeEnvironment\n      canDragAndDrop\n      canDropOnFolder\n      canReorderItems\n      dataProvider={dataProvider}\n      getItemTitle={item => item.data}\n      viewState={{\n        \'tree-1\': {\n          expandedItems: [],\n        },\n      }}\n    >\n      <button type="button" onClick={injectItem}>\n        Inject item\n      </button>\n      <button type="button" onClick={removeItem}>\n        Remove item\n      </button>\n      <Tree treeId="tree-1" rootItem="root" treeLabel="Tree Example" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n')),(0,a.kt)("h2",{id:"creating-the-data-provider-with-data"},"Creating the data provider with data"),(0,a.kt)("p",null,"First, create the data provider. You want to make sure it isn't recreated on re-renders, so memoize\nit in the component in which it is defined."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const dataProvider = useMemo(\n  () =>\n    new StaticTreeDataProvider(items, (item, data) => ({\n      ...item,\n      data,\n    })),\n  [items]\n);\n")),(0,a.kt)("p",null,"The items is a record mapping item ids to tree items, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'const items = [\n  {\n    index: "item-id",\n    data: { arbitraryData: 123, name: "Hello" },\n    children: ["item-id-1", "item-id-2"],\n    isFolder: true\n  }\n]\n')),(0,a.kt)("p",null,"Note that, whatever you provide to the ",(0,a.kt)("inlineCode",{parentName:"p"},"getItemTitle")," prop is used to infer the item display name."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"jsx",jsx:!0},"<UncontrolledTreeEnvironment\n  getItemTitle={item => item.data.name}\n/>\n")),(0,a.kt)("h2",{id:"apply-changes-from-outside"},"Apply changes from outside"),(0,a.kt)("p",null,"You can apply changes to the underlying data source. Just make sure to let RCT know about that by\nemitting a change event on the affected items. Note that, if you add or remove items, the affected item\nis the parent item, not the added or removed items."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const injectItem = () => {\n  const rand = `${Math.random()}`;\n  items[rand] = { data: 'New Item', index: rand };\n  items.root.children.push(rand);\n  dataProvider.onDidChangeTreeDataEmitter.emit(['root']);\n};\n\nconst removeItem = () => {\n  if (items.root.children.length === 0) return;\n  items.root.children.pop();\n  dataProvider.onDidChangeTreeDataEmitter.emit(['root']);\n};\n")),(0,a.kt)("h2",{id:"reacting-to-drag-events"},"Reacting to Drag Events"),(0,a.kt)("p",null,"Drag changes are always immediately applied to the visualization, so make sure to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"canDropAt"),"\nprop to customize if that should not work in all cases. The static tree data emits tree change events similar\nto the ones you would emit when applying changes from outside, so you can react to them in the same way."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"dataProvider.onDidChangeTreeData(changedItemIds => {\n  console.log(changedItemIds);\n});\n")),(0,a.kt)("h2",{id:"reacting-to-rename-events"},"Reacting to Rename Events"),(0,a.kt)("p",null,"The second (optional) parameter of the static tree data provider lets you react to rename events. Note that\nyou can customize whether renaming is possible in the first place through the ",(0,a.kt)("inlineCode",{parentName:"p"},"canRename")," prop."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const dataProvider = new StaticTreeDataProvider(items, (item, newName) => {\n  // Return the patched item with new item name here\n  return {\n    ...item,\n    data: { ...item.data, name: newName },\n  };\n});\n`\n")))}m.isMDXComponent=!0},876:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>u});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),p=c(n),u=a,h=p["".concat(s,".").concat(u)]||p[u]||m[u]||o;return n?r.createElement(h,i(i({ref:t},l),{},{components:n})):r.createElement(h,i({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d.mdxType="string"==typeof e?e:a,i[1]=d;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);