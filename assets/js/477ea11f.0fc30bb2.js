"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3028],{8667:(e,t,n)=>{n.d(t,{i:()=>o});var r=n(7896),a=n(2784),i=n(8873);const o=e=>{let{storyName:t,iframeProps:n}=e;return a.createElement(i.Z,(0,r.Z)({src:`/storybook/iframe.html?id=${t}&args=&viewMode=story`,frameBorder:0,allowtransparency:"true",style:n.width||n.minWidth||n.maxWidth?{}:{width:"1px",minWidth:"100%"}},n??{}))}},3693:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var r=n(7896),a=(n(2784),n(876)),i=n(8667);const o={sidebar_position:6},l="Search Functionality",s={unversionedId:"guides/search",id:"guides/search",title:"Search Functionality",description:"Searching for items is natively supported. It looks through all items that are curretly visible in the",source:"@site/docs/guides/search.mdx",sourceDirName:"guides",slug:"/guides/search",permalink:"/docs/guides/search",draft:!1,editUrl:"https://github.com/lukasbach/react-complex-tree/edit/main/packages/docs/docs/guides/search.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Drag and Drop Customizability",permalink:"/docs/guides/drag-and-drop"},next:{title:"Renaming Functionality",permalink:"/docs/guides/renaming"}},c={},d=[{value:"Example",id:"example",level:2},{value:"Configurability",id:"configurability",level:2},{value:"Programmatic interaction",id:"programmatic-interaction",level:2},{value:"Finding items that are not loaded in",id:"finding-items-that-are-not-loaded-in",level:2}],m={toc:d};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"search-functionality"},"Search Functionality"),(0,a.kt)("p",null,"Searching for items is natively supported. It looks through all items that are curretly visible in the\ntree, similar to how other tree implementations do it such as the tree view in IntelliJ or VsCode. Search\nis automatically started if the tree is focused and the user starts typing."),(0,a.kt)("p",null,"This also implements the accessibility feature where entering a single character while focusing the tree\nshould move the focus to the first item that matches the character. See the\n",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/wai-aria-practices-1.1/examples/treeview/treeview-2/treeview-2a.html#kbd_label"},"W3C spec for keyboard bindings"),"\nfor more details."),(0,a.kt)(i.i,{storyName:"auto-demo-autodemo-component--search-demo",iframeProps:{width:600},mdxType:"StoryEmbed"}),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"All props that can be provided to the tree environment to control search capabilities are documented\nin the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/interfaces/TreeCapabilities"},"TreeCapabilities interface"),".")),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"(TODO) Apparently the search currently does not work properly in the docs pages, where the search input\nis not properly shown. This is an issue with our documentation tooling, not the framework.\nWorking examples are available in the storybook.")),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"Try focusing the tree (i.e. by clicking on it) and start typing to search."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  return (\n    <UncontrolledTreeEnvironment\n      dataProvider={new StaticTreeDataProvider(longTree.items, (item, data) => ({ ...item, data }))}\n      getItemTitle={item => item.data}\n      viewState={{\n        'tree-1': {\n          expandedItems: ['Fruit', 'Meals'],\n        },\n      }}\n    >\n      <Tree treeId=\"tree-1\" rootItem=\"root\" treeLabel=\"Tree Example\" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n")),(0,a.kt)("h2",{id:"configurability"},"Configurability"),(0,a.kt)("p",null,"The prop ",(0,a.kt)("inlineCode",{parentName:"p"},"canSearchByStartingTyping")," manages whether the search can be initiated by just starting to type\nwhile focusing the tree. In the following example, the hotkey ",(0,a.kt)("inlineCode",{parentName:"p"},"F1")," needs to be pressed to start search."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  return (\n    <UncontrolledTreeEnvironment\n      dataProvider={new StaticTreeDataProvider(longTree.items, (item, data) => ({ ...item, data }))}\n      getItemTitle={item => item.data}\n      viewState={{\n        'tree-2': {\n          expandedItems: ['Fruit', 'Meals'],\n        },\n      }}\n      canSearchByStartingTyping={false}\n      keyboardBindings={{\n        startSearch: ['f1'],\n      }}\n    >\n      <Tree treeId=\"tree-2\" rootItem=\"root\" treeLabel=\"Tree Example\" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n")),(0,a.kt)("p",null,"Search can also be disabled completely by setting the prop ",(0,a.kt)("inlineCode",{parentName:"p"},"canSearch")," to false."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  return (\n    <UncontrolledTreeEnvironment\n      dataProvider={new StaticTreeDataProvider(longTree.items, (item, data) => ({ ...item, data }))}\n      getItemTitle={item => item.data}\n      viewState={{\n        'tree-3': {\n          expandedItems: ['Fruit', 'Meals'],\n        },\n      }}\n      canSearch={false}\n    >\n      <Tree treeId=\"tree-3\" rootItem=\"root\" treeLabel=\"Tree Example\" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n")),(0,a.kt)("h2",{id:"programmatic-interaction"},"Programmatic interaction"),(0,a.kt)("p",null,"This feature can programmatically be controlled by pulling a React Ref either from the tree environment\nor the tree itself, and acting on the Ref object. ",(0,a.kt)("a",{parentName:"p",href:"/docs/guides/refs"},"Read the documentation on externally interacting\nwith the tree via Refs")," to find out more."),(0,a.kt)("h2",{id:"finding-items-that-are-not-loaded-in"},"Finding items that are not loaded in"),(0,a.kt)("p",null,"The search functionality only searches through items that are currently visible in the tree. This keeps the\nfunctionality in par with similar tree implementations, where you can directly type into a tree to jump to already\navailable items, giving an easier way to scroll through large trees."),(0,a.kt)("p",null,"Searching through all items and expanding potentially hidden items to expose the searched item is a bit more complicated,\nand depends on your data structure to work. Because there are several ways to define a data structure with RCT,\nit is up to you to implement the logic to actually find the item that should be displayed. Once you determined a path\nto the item (i.e. an array of item ids), you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"expandSubsequently(treeId, path)")," function in the\n",(0,a.kt)("a",{parentName:"p",href:"/docs/api/interfaces/TreeEnvironmentRef"},"Tree environment ref")," to expand the tree to the searched item, or use\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"expandSubsequently(path)")," function in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/interfaces/TreeRef"},"Tree Ref"),"."),(0,a.kt)("p",null,'Try entering "blackberry" in the example below, and clicking on "Find item":'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function App() {\n  const [search, setSearch] = useState(\'\');\n  const tree = useRef(null)\n\n  const dataProvider = useMemo(\n    () =>\n      new StaticTreeDataProvider(longTree.items, (item, data) => ({\n        ...item,\n        data,\n      })),\n    []\n  );\n\n  const findItemPath = useCallback(\n    async (search, searchRoot = \'root\') => {\n      const item = await dataProvider.getTreeItem(searchRoot);\n      if (item.data.toLowerCase().includes(search.toLowerCase())) {\n        return [item.index];\n      }\n      const searchedItems = await Promise.all(\n        item.children && item.children.map(child => findItemPath(search, child)) || []\n      );\n      const result = searchedItems.find(item => item !== null);\n      if (!result) {\n        return null;\n      }\n      return [item.index, ...result];\n    },\n    [dataProvider]\n  );\n\n  const find = useCallback(\n    e => {\n      e.preventDefault();\n      if (search) {\n        findItemPath(search).then(path => {\n          if (path) {\n            // wait for full path including leaf, to make sure it loaded in\n            tree.current?.expandSubsequently(path).then(() => {\n                tree.current.selectItems([path[path.length - 1]]);\n                tree.current.focusItem(path[path.length - 1]);\n              });\n          }\n        });\n      }\n    },\n    [findItemPath, search]\n  );\n\n  return (\n    <>\n      <form onSubmit={find}>\n        <input\n          value={search}\n          onChange={e => setSearch(e.target.value)}\n          placeholder="Search..."\n        />\n        <button type="submit">Find item</button>\n      </form>\n      <UncontrolledTreeEnvironment\n        dataProvider={dataProvider}\n        getItemTitle={item => item.data}\n        viewState={{\n          \'tree-4\': {},\n        }}\n      >\n        <Tree\n          treeId="tree-4"\n          rootItem="root"\n          treeLabel="Tree Example"\n          ref={tree}\n        />\n      </UncontrolledTreeEnvironment>\n    </>\n  );\n}\n')))}p.isMDXComponent=!0},876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),u=a,h=p["".concat(s,".").concat(u)]||p[u]||m[u]||i;return n?r.createElement(h,o(o({ref:t},d),{},{components:n})):r.createElement(h,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);